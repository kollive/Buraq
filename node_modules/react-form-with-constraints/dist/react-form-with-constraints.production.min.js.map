{"version":3,"file":"react-form-with-constraints.production.min.js","sources":["../src/withValidateEventEmitter.ts","../src/EventEmitter.ts","../src/fieldWithoutFeedback.ts","../src/FieldsStore.ts","../src/FormWithConstraints.tsx","../src/FieldFeedbacks.tsx","../src/FieldFeedback.tsx"],"sourcesContent":["import { EventEmitter } from './EventEmitter';\nimport Input from './Input';\nimport Constructor from './Constructor';\n\nexport const ValidateEvent = 'VALIDATE_EVENT';\n\nexport type ValidateEventListener = (input: Input) => void;\n\nexport interface IValidateEventEmitter {\n  emitValidateEvent(input: Input): void;\n  addValidateEventListener(listener: ValidateEventListener): void;\n  removeValidateEventListener(listener: ValidateEventListener): void;\n}\n\n// See TypeScript 2.2 Support for Mix-in classes https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html\nexport function withValidateEventEmitter<TBase extends Constructor<{}>>(Base: TBase) {\n  return class ValidateEventEmitter extends Base implements IValidateEventEmitter {\n    validateEventEmitter = new EventEmitter();\n\n    emitValidateEvent(input: Input) {\n      this.validateEventEmitter.emit(ValidateEvent, input);\n    }\n\n    addValidateEventListener(listener: ValidateEventListener) {\n      this.validateEventEmitter.addListener(ValidateEvent, listener);\n    }\n\n    removeValidateEventListener(listener: ValidateEventListener) {\n      this.validateEventEmitter.removeListener(ValidateEvent, listener);\n    }\n  };\n}\n","// FIXME\n// See Thoughts about variadic generics? https://github.com/Microsoft/TypeScript/issues/1773\n// See Proposal: Variadic Kinds -- Give specific types to variadic functions https://github.com/Microsoft/TypeScript/issues/5453\nexport type Args = any[];\n\nexport type Listener = (...args: Args) => void;\n\nexport class EventEmitter {\n  listeners = new Map<string, Listener[]>();\n\n  emit(eventName: string, ...args: Args) {\n    const listeners = this.listeners.get(eventName)!;\n\n    // Assert disabled: mess with the unit tests\n    //console.assert(listeners !== undefined, `Unknown event '${eventName}'`);\n\n    if (listeners !== undefined) {\n      console.assert(listeners.length > 0, `No listener for event '${eventName}'`);\n      listeners.forEach(listener => listener(...args));\n    }\n  }\n\n  addListener(eventName: string, listener: Listener) {\n    if (!this.listeners.has(eventName)) this.listeners.set(eventName, []);\n    const listeners = this.listeners.get(eventName)!;\n    console.assert(listeners.indexOf(listener) === -1, `Listener already added for event '${eventName}'`);\n    listeners.push(listener);\n  }\n\n  // See https://nodejs.org/api/events.html#events_emitter_removelistener_eventname_listener\n  // \"removeListener will remove, at most, one instance of a listener from the listener array.\n  // If any single listener has been added multiple times to the listener array for the specified eventName,\n  // then removeListener must be called multiple times to remove each instance.\"\n  removeListener(eventName: string, listener: Listener) {\n    const listeners = this.listeners.get(eventName)!;\n    console.assert(listeners !== undefined, `Unknown event '${eventName}'`);\n\n    const index = listeners.lastIndexOf(listener);\n    console.assert(index > -1, `Listener not found for event '${eventName}'`);\n    listeners.splice(index, 1);\n\n    if (listeners.length === 0) this.listeners.delete(eventName);\n  }\n}\n","import { Field } from './index';\n\nconst fieldWithoutFeedback: Readonly<Field> = {\n  dirty: false,\n  errors: new Set(),\n  warnings: new Set(),\n  infos: new Set(),\n  validationMessage: ''\n};\n\nexport default fieldWithoutFeedback;\n","import { Fields, Field } from './Fields';\nimport { EventEmitter } from './EventEmitter';\nimport fieldWithoutFeedback from './fieldWithoutFeedback';\n\nexport enum FieldEvent {\n  Added = 'FIELD_ADDED',\n  Removed = 'FIELD_REMOVED',\n  Updated = 'FIELD_UPDATED'\n}\n\nexport class FieldsStore extends EventEmitter {\n  // Why Object.create(null) insteaf of just {}? See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Objects_and_maps_compared\n  fields: Fields = Object.create(null);\n\n  addField(fieldName: string) {\n    if (this.fields[fieldName] === undefined) {\n      const newField = fieldWithoutFeedback;\n      this.fields[fieldName] = newField;\n      this.emit(FieldEvent.Added, fieldName, newField);\n    }\n  }\n\n  removeField(fieldName: string) {\n    console.assert(this.fields[fieldName] !== undefined, `Unknown field '${fieldName}'`);\n    delete this.fields[fieldName];\n    this.emit(FieldEvent.Removed, fieldName);\n  }\n\n  cloneField(fieldName: string) {\n    const field = this.fields[fieldName]!;\n    console.assert(field !== undefined, `Unknown field '${fieldName}'`);\n    const newField: Field = {\n      dirty: field.dirty,\n      errors: new Set(field.errors),\n      warnings: new Set(field.warnings),\n      infos: new Set(field.infos),\n      validationMessage: field.validationMessage\n    };\n    return newField;\n  }\n\n  updateField(fieldName: string, field: Field) {\n    console.assert(this.fields[fieldName] !== undefined, `Unknown field '${fieldName}'`);\n    this.fields[fieldName] = field;\n    this.emit(FieldEvent.Updated, fieldName);\n  }\n\n  // Clear the errors/warnings/infos each time we re-validate the input,\n  // this solves the problem with the errors order and show=\"first\", example:\n  // <FieldFeedbacks for=\"username\" show=\"first\"> key=0\n  //   <FieldFeedback ...> key=0.0\n  //   <FieldFeedback ...> key=0.1\n  // </FieldFeedbacks>\n  // We want the first FieldFeedback in the DOM that matches to be displayed\n  // + we have a special case where we could have multiple FieldFeedbacks for the same field\n  removeFieldFor(fieldName: string, fieldFeedbacksKey: number) {\n    const field = this.fields[fieldName]!;\n    console.assert(field !== undefined, `Unknown field '${fieldName}'`);\n\n    // reject is the opposite of filter, see https://lodash.com/docs/#reject\n    // Example: fieldFeedbacksKey = 5, fieldFeedbackKey = 5.2, Math.floor(5.2) = 5\n    const reject = (fieldFeedbackKey: number) => fieldFeedbacksKey !== Math.floor(fieldFeedbackKey);\n\n    // FIXME\n    // With TypeScript ES5 [...set] is translated to __spread(set)\n    // and __spread(set) is buggy with react-native Android\n    // works with iOS\n    // No idea why it's buggy under Android\n    // This should be removed when TypeScript target will be changed for > ES5\n    field.errors = new Set(/*[...field.errors]*/Array.from(field.errors).filter(reject));\n    field.warnings = new Set(/*[...field.warnings]*/Array.from(field.warnings).filter(reject));\n    field.infos = new Set(/*[...field.infos]*/Array.from(field.infos).filter(reject));\n\n    this.emit(FieldEvent.Updated, fieldName);\n  }\n\n  // Retrieve errors/warnings/infos only related to a given FieldFeedbacks\n  getFieldFor(fieldName: string, fieldFeedbacksKey: number) {\n    const field = this.fields[fieldName]!;\n    console.assert(field !== undefined, `Unknown field '${fieldName}'`);\n\n    // Example: fieldFeedbacksKey = 5, fieldFeedbackKey = 5.2, Math.floor(5.2) = 5\n    const filter = (fieldFeedbackKey: number) => fieldFeedbacksKey === Math.floor(fieldFeedbackKey);\n\n    const fieldFor: Readonly<Field> = {\n      dirty: field.dirty,\n\n      // FIXME\n      // With TypeScript ES5 [...set] is translated to __spread(set)\n      // and __spread(set) is buggy with react-native Android\n      // works with iOS\n      // No idea why it's buggy under Android\n      // This should be removed when TypeScript target will be changed for > ES5\n      errors: new Set(/*[...field.errors]*/Array.from(field.errors).filter(filter)),\n      warnings: new Set(/*[...field.warnings]*/Array.from(field.warnings).filter(filter)),\n      infos: new Set(/*[...field.infos]*/Array.from(field.infos).filter(filter)),\n\n      validationMessage: field.validationMessage\n    };\n    return fieldFor;\n  }\n\n  containErrors(...fieldNames: string[]) {\n    return fieldNames.some(fieldName => {\n      const field = this.fields[fieldName];\n      return field !== undefined && field.errors.size > 0;\n    });\n  }\n\n  containWarnings(...fieldNames: string[]) {\n    return fieldNames.some(fieldName => {\n      const field = this.fields[fieldName];\n      return field !== undefined && field.warnings.size > 0;\n    });\n  }\n\n  containInfos(...fieldNames: string[]) {\n    return fieldNames.some(fieldName => {\n      const field = this.fields[fieldName];\n      return field !== undefined && field.infos.size > 0;\n    });\n  }\n\n  areValidDirtyWithoutWarnings(...fieldNames: string[]) {\n    return fieldNames.some(fieldName => {\n      const field = this.fields[fieldName];\n      return field !== undefined && field.dirty === true && field.errors.size === 0 && field.warnings.size === 0;\n    });\n  }\n}\n","import * as React from 'react';\nimport * as PropTypes from 'prop-types';\n\nimport { IValidateEventEmitter, withValidateEventEmitter } from './withValidateEventEmitter';\n// @ts-ignore\n// TS6133: 'EventEmitter' is declared but its value is never read.\n// FIXME See https://github.com/Microsoft/TypeScript/issues/9944#issuecomment-309903027\nimport { EventEmitter } from './EventEmitter';\nimport Input from './Input';\nimport { FieldsStore } from './FieldsStore';\n\n// See Form data validation https://developer.mozilla.org/en-US/docs/Learn/HTML/Forms/Form_validation\n// See ReactJS Form Validation Approaches http://moduscreate.com/reactjs-form-validation-approaches/\n\n/*\nFormWithConstraints\n  - input\n  - FieldFeedbacks\n    - FieldFeedback\n    - FieldFeedback\n    - ...\n  - input\n  - FieldFeedbacks\n    - FieldFeedback\n    - FieldFeedback\n    - ...\n  - ...\n\nFormWithConstraints contains the FieldsStore:\n{\n  username: {\n    dirty: true,\n    errors: [0.0], // List of FieldFeedback keys\n    warnings: [0.2, 1.1],\n    infos: []\n  },\n  password: {\n    dirty: false,\n    errors: [],\n    warnings: [],\n    infos: []\n  }\n}\nFieldsStore is passed to FieldFeedbacks and FieldFeedback thanks to React context.\n\nMost of the intelligence is inside FieldFeedback validate() and render()\n\nWhen an input changes (validateFields()):\n => FormWithConstraints notifies all FieldFeedbacks\n  => FieldFeedbacks filters unrelated input changes and then notifies its FieldFeedback (validate())\n   => FieldFeedback updates the FieldsStore and emits an event (validate())\n    => FieldFeedbacks re-renders\n*/\n\nexport interface FormWithConstraintsChildContext {\n  form: IFormWithConstraints;\n}\n\nexport interface FormWithConstraintsProps extends React.FormHTMLAttributes<HTMLFormElement> {}\n\nexport interface IFormWithConstraints extends IValidateEventEmitter {\n  fieldsStore: FieldsStore;\n  computeFieldFeedbacksKey(): number;\n}\n\nexport class FormWithConstraintsComponent extends React.Component<FormWithConstraintsProps> {}\nexport class FormWithConstraints extends withValidateEventEmitter(FormWithConstraintsComponent) implements IFormWithConstraints {\n  static childContextTypes = {\n    form: PropTypes.object.isRequired\n  };\n  getChildContext(): FormWithConstraintsChildContext {\n    return {\n      form: this\n    };\n  }\n\n  // Could be named innerRef instead\n  form: HTMLFormElement;\n\n  fieldsStore = new FieldsStore();\n\n  private fieldFeedbacksKey = 0;\n  computeFieldFeedbacksKey() {\n    return this.fieldFeedbacksKey++;\n  }\n\n  /**\n   * Validates the given fields, either HTMLInputElements or field names.\n   * If called without arguments, validates all fields ($('[name]')).\n   */\n  validateFields(...inputsOrNames: Array<Input | string>) {\n    const inputs = inputsOrNames.filter(inputOrName => typeof inputOrName !== 'string') as Input[];\n    const fieldNames = inputsOrNames.filter(inputOrName => typeof inputOrName === 'string') as string[];\n\n    let otherInputs: Input[] = [];\n\n    // [name] matches <input name=\"...\">, <select name=\"...\">, <button name=\"...\">, ...\n    if (inputsOrNames.length === 0) {\n      otherInputs = this.form.querySelectorAll('[name]') as any;\n    }\n    if (fieldNames.length > 0) {\n      const selectors = fieldNames.map(fieldName => `[name=\"${fieldName}\"]`);\n      otherInputs = this.form.querySelectorAll(selectors.join(', ')) as any;\n    }\n\n    [\n      ...inputs,\n      ...otherInputs\n    ].forEach(input => this.emitValidateEvent(input));\n  }\n\n  // Lazy check => the fields structure might be incomplete\n  isValid() {\n    const fieldNames = Object.keys(this.fieldsStore.fields);\n    return !this.fieldsStore.containErrors(...fieldNames);\n  }\n\n  render() {\n    const { children, ...formProps } = this.props;\n    return <form ref={form => this.form = form!} {...formProps}>{children}</form>;\n  }\n}\n","import * as React from 'react';\nimport * as PropTypes from 'prop-types';\n\nimport { FormWithConstraintsChildContext } from './FormWithConstraints';\nimport { IValidateEventEmitter, withValidateEventEmitter } from './withValidateEventEmitter';\n// @ts-ignore\n// TS6133: 'EventEmitter' is declared but its value is never read.\n// FIXME See https://github.com/Microsoft/TypeScript/issues/9944#issuecomment-309903027\nimport { EventEmitter } from './EventEmitter';\nimport Input from './Input';\nimport { FieldEvent } from './FieldsStore';\n\nexport interface FieldFeedbacksProps extends React.HTMLAttributes<HTMLDivElement> {\n  for: string;\n\n  /**\n   * first => shows only the first error or warning (if no error) encountered, infos are always displayed\n   * all => shows everything\n   */\n  show?: 'first' | 'all';\n}\n\nexport interface FieldFeedbacksChildContext {\n  fieldFeedbacks: IFieldFeedbacks;\n}\n\nexport interface IFieldFeedbacks extends IValidateEventEmitter {\n  props: FieldFeedbacksProps;\n  key: number;\n  computeFieldFeedbackKey(): number;\n}\n\nexport class FieldFeedbacksComponent extends React.Component<FieldFeedbacksProps> {}\nexport class FieldFeedbacks extends withValidateEventEmitter(FieldFeedbacksComponent) {\n  static defaultProps: Partial<FieldFeedbacksProps> = {\n    show: 'first'\n  };\n\n  static contextTypes = {\n    form: PropTypes.object.isRequired\n  };\n  context: FormWithConstraintsChildContext;\n\n  static childContextTypes = {\n    fieldFeedbacks: PropTypes.object.isRequired\n  };\n  getChildContext(): FieldFeedbacksChildContext {\n    return {\n      fieldFeedbacks: this\n    };\n  }\n\n  key: number;\n\n  constructor(props: FieldFeedbacksProps, context: FormWithConstraintsChildContext) {\n    super(props);\n\n    this.validate = this.validate.bind(this);\n    this.reRender = this.reRender.bind(this);\n\n    this.key = context.form.computeFieldFeedbacksKey();\n  }\n\n  // FieldFeedback key = FieldFeedbacks key + increment\n  // Examples:\n  // 0.0, 0.1, 0.2 with 0 being the FieldFeedbacks key\n  // 1.0, 1.1, 1.2 with 1 being the FieldFeedbacks key\n  //\n  // This solves the problem when having multiple FieldFeedbacks with the same for attribute:\n  // <FieldFeedbacks for=\"username\" show=\"first\"> key=0\n  //   <FieldFeedback ...> key=0.0\n  //   <FieldFeedback ...> key=0.1\n  // </FieldFeedbacks>\n  // <FieldFeedbacks for=\"username\" show=\"all\"> key=1\n  //   <FieldFeedback ...> key=1.0\n  //   <FieldFeedback ...> key=1.1\n  //   <FieldFeedback ...> key=1.2\n  // </FieldFeedbacks>\n  //\n  // We could use a string here instead of a number\n  private fieldFeedbackKey = 0;\n  computeFieldFeedbackKey() {\n    // Example: this.key = 5, this.fieldFeedbackKey = 2 => 5 + 2 / 10 = 5 + 0.2 = 5.2\n    return this.key + this.fieldFeedbackKey++ / 10;\n  }\n\n  componentWillMount() {\n    const fieldName = this.props.for;\n    this.context.form.fieldsStore.addField(fieldName);\n\n    this.context.form.addValidateEventListener(this.validate);\n    this.context.form.fieldsStore.addListener(FieldEvent.Updated, this.reRender);\n  }\n\n  componentWillUnmount() {\n    const fieldName = this.props.for;\n    this.context.form.fieldsStore.removeField(fieldName);\n\n    this.context.form.removeValidateEventListener(this.validate);\n    this.context.form.fieldsStore.removeListener(FieldEvent.Updated, this.reRender);\n  }\n\n  validate(input: Input) {\n    const { for: fieldName } = this.props;\n\n    if (input.name === fieldName) { // Ignore the event if it's not for us\n      // Clear the errors/warnings/infos each time we re-validate the input\n      this.context.form.fieldsStore.removeFieldFor(fieldName, this.key);\n\n      this.emitValidateEvent(input);\n    }\n  }\n\n  reRender(_fieldName: string) {\n    const { for: fieldName } = this.props;\n    if (fieldName === _fieldName) { // Ignore the event if it's not for us\n      this.forceUpdate();\n    }\n  }\n\n  render() {\n    const { for: fieldName, show, children, ...divProps } = this.props;\n    return <div {...divProps}>{children}</div>;\n  }\n}\n","import * as React from 'react';\nimport * as PropTypes from 'prop-types';\n\nimport { FormWithConstraintsChildContext } from './FormWithConstraints';\nimport { FieldFeedbacksChildContext } from './FieldFeedbacks';\nimport Input from './Input';\n\nexport type WhenString =\n  | '*'\n  | 'badInput'        // input type=\"number\"\n  | 'patternMismatch' // pattern attribute\n  | 'rangeOverflow'   // max attribute\n  | 'rangeUnderflow'  // min attribute\n  | 'stepMismatch'    // step attribute\n  | 'tooLong'         // maxlength attribute\n  | 'tooShort'        // minlength attribute\n  | 'typeMismatch'    // input type=\"email\" or input type=\"url\"\n  | 'valueMissing';   // required attribute\nexport type WhenFn = (value: string) => boolean;\nexport type When = WhenString | WhenFn;\n\nexport interface FieldFeedbackProps extends React.HTMLAttributes<HTMLDivElement> {\n  when: When;\n  error?: boolean;\n  warning?: boolean;\n  info?: boolean;\n}\n\nexport type FieldFeedbackContext = FormWithConstraintsChildContext & FieldFeedbacksChildContext;\n\nexport class FieldFeedback extends React.Component<FieldFeedbackProps> {\n  static contextTypes = {\n    form: PropTypes.object.isRequired,\n    fieldFeedbacks: PropTypes.object.isRequired\n  };\n  context: FieldFeedbackContext;\n\n  key: number;\n\n  constructor(props: FieldFeedbackProps, context: FieldFeedbackContext) {\n    super(props);\n\n    this.validate = this.validate.bind(this);\n\n    this.key = context.fieldFeedbacks.computeFieldFeedbackKey();\n  }\n\n  componentWillMount() {\n    this.context.fieldFeedbacks.addValidateEventListener(this.validate);\n  }\n\n  componentWillUnmount() {\n    this.context.fieldFeedbacks.removeValidateEventListener(this.validate);\n  }\n\n  // Generates Field for Fields structure\n  validate(input: Input) {\n    const { when, warning, info } = this.props;\n    const { for: fieldName } = this.context.fieldFeedbacks.props;\n\n    let show = false;\n\n    if (typeof when === 'function') {\n      const constraintViolation = when(input.value);\n      if (constraintViolation) {\n        show = true;\n      }\n    }\n\n    else if (typeof when === 'string') {\n      const validity = input.validity;\n\n      if (!validity.valid) {\n        if (when === '*') {\n          show = true;\n        }\n        else if (\n          validity.badInput && when === 'badInput' ||\n          validity.patternMismatch && when === 'patternMismatch' ||\n          validity.rangeOverflow && when === 'rangeOverflow' ||\n          validity.rangeUnderflow && when === 'rangeUnderflow' ||\n          validity.stepMismatch && when === 'stepMismatch' ||\n          validity.tooLong && when === 'tooLong' ||\n          validity.tooShort && when === 'tooShort' ||\n          validity.typeMismatch && when === 'typeMismatch' ||\n          validity.valueMissing && when === 'valueMissing') {\n\n          show = true;\n        }\n      }\n    }\n\n    else {\n      throw new TypeError(`Invalid FieldFeedback 'when' type: ${typeof when}`);\n    }\n\n    // Update the Fields structure\n    const field = this.context.form.fieldsStore.cloneField(fieldName);\n    field.dirty = true;\n    field.validationMessage = input.validationMessage;\n    if (show) {\n      // No need to \"append if not already there\": Set ignores duplicates\n      if (warning) field.warnings.add(this.key);\n      else if (info) field.infos.add(this.key);\n      else field.errors.add(this.key); // Feedback type is error if nothing is specified\n    }\n    this.context.form.fieldsStore.updateField(fieldName, field);\n  }\n\n  className() {\n    const { for: fieldName, show } = this.context.fieldFeedbacks.props;\n\n    // Retrieve errors/warnings/infos only related to the parent FieldFeedbacks\n    const { errors, warnings, infos } = this.context.form.fieldsStore.getFieldFor(fieldName, this.context.fieldFeedbacks.key);\n\n    const firstError = errors.values().next().value;\n    const firstWarning = warnings.values().next().value;\n\n    let className: string | undefined;\n\n    if (errors.has(this.key) && (show === 'all' || (show === 'first' && firstError === this.key))) {\n      className = 'error';\n    }\n    else if (warnings.has(this.key) && (errors.size === 0 && (show === 'all' || (show === 'first' && firstWarning === this.key)))) {\n      className = 'warning';\n    }\n    else if (infos.has(this.key)) {\n      className = 'info';\n    }\n\n    return className;\n  }\n\n  render() {\n    const { when, error, warning, info, className, children, ...divProps } = this.props;\n    const { for: fieldName } = this.context.fieldFeedbacks.props;\n    const { validationMessage } = this.context.form.fieldsStore.getFieldFor(fieldName, this.context.fieldFeedbacks.key);\n\n    let classes = this.className();\n\n    let feedback = null;\n    if (classes !== undefined) { // Means the FieldFeedback should be displayed\n      classes = className !== undefined ? `${className} ${classes}` : classes;\n      feedback = children !== undefined ? children : validationMessage;\n    }\n\n    return feedback !== null ? <div {...divProps} className={classes}>{feedback}</div> : null;\n  }\n}\n"],"names":["Base","_this","EventEmitter","tslib_1.__extends","ValidateEventEmitter","input","this","validateEventEmitter","emit","ValidateEvent","listener","addListener","removeListener","Map","eventName","_i","args","listeners","get","undefined","console","assert","length","forEach","has","set","indexOf","push","index","lastIndexOf","splice","delete","fieldWithoutFeedback","dirty","errors","Set","warnings","infos","validationMessage","FieldEvent","Object","create","FieldsStore","fieldName","fields","newField","Added","Removed","field","Updated","fieldFeedbacksKey","reject","fieldFeedbackKey","Math","floor","Array","from","filter","fieldNames","some","size","React.Component","FormWithConstraints","form","inputsOrNames","inputs","inputOrName","otherInputs","querySelectorAll","selectors","map","join","tslib_1.__spread","emitValidateEvent","keys","fieldsStore","_a","containErrors","children","formProps","React.createElement","ref","PropTypes.object","isRequired","withValidateEventEmitter","FormWithConstraintsComponent","props","context","_super","validate","bind","reRender","key","computeFieldFeedbacksKey","FieldFeedbacks","fieldFeedbacks","for","addField","addValidateEventListener","removeField","removeValidateEventListener","name","removeFieldFor","_fieldName","forceUpdate","divProps","show","FieldFeedbacksComponent","computeFieldFeedbackKey","FieldFeedback","when","warning","info","value","TypeError","validity","valid","badInput","patternMismatch","rangeOverflow","rangeUnderflow","stepMismatch","tooLong","tooShort","typeMismatch","valueMissing","cloneField","add","updateField","className","_b","firstError","values","next","firstWarning","classes","feedback"],"mappings":"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"}